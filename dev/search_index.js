var documenterSearchIndex = {"docs":
[{"location":"#Public-interface","page":"Public interface","title":"Public interface","text":"","category":"section"},{"location":"","page":"Public interface","title":"Public interface","text":"Pages = [\"index.md\"]","category":"page"},{"location":"","page":"Public interface","title":"Public interface","text":"Modules = [PortAudio]\nPrivate = false","category":"page"},{"location":"#PortAudio.PortAudioStream","page":"Public interface","title":"PortAudio.PortAudioStream","text":"PortAudioStream(input_channels = 2, output_channels = 2; options...)\nPortAudioStream(duplex_device, input_channels = 2, output_channels = 2; options...)\nPortAudioStream(input_device, output_device, input_channels = 2, output_channels = 2; options...)\n\nAudio devices can either be PortAudioDevice instances as returned by devices, or strings with the device name as reported by the operating system. Set input_channels to 0 for an output only stream; set output_channels to 0 for an input only steam. If you pass the function maximum instead of a number of channels, use the maximum channels allowed by the corresponding device. If a single duplex_device is given, it will be used for both input and output. If no devices are given, the system default devices will be used.\n\nThe PortAudioStream type supports all the stream and buffer features defined SampledSignals.jl by default. For example, if you load SampledSignals with using SampledSignals you can read 5 seconds to a buffer with buf = read(stream, 5s), regardless of the sample rate of the device. write(stream, stream) will set up a loopback that will read from the input and play it back on the output.\n\nOptions:\n\nadjust_channels = false: If set to true, if either input_channels or output_channels exceeds the corresponding device maximum, adjust down to the maximum.\ncall_back = C_NULL: The PortAudio call-back function. Currently, passing anything except C_NULL is unsupported.\neltype = Float32: Sample type of the audio stream\nflags = PortAudio.paNoFlag: PortAudio flags\nframes_per_buffer = 128: the number of frames per buffer\ninput_info = C_NULL: host API specific stream info for the input device. Currently, passing anything except C_NULL is unsupported.\nlatency = nothing: Requested latency. Stream could underrun when too low, consider using the defaults.  If left as nothing, use the defaults below:\nFor input/output only streams, use the corresponding device's default high latency.\nFor duplex streams, use the max of the default high latency of the input and output devices.\noutput_info = C_NULL: host API specific stream info for the output device. Currently, passing anything except C_NULL is unsupported.\nreader = PortAudio.SampledSignalsReader(): the scribe that will read input. Defaults to a PortAudio.SampledSignalsReader. Users can pass custom scribes; see PortAudio.Scribe.\nsamplerate = nothing: Sample rate. If left as nothing, use the defaults below:\nFor input/output only streams, use the corresponding device's default sample rate.\nFor duplex streams, use the default sample rate if the default sample rates for the input and output devices match, otherwise throw an error.\nwarn_xruns = true: Display a warning if there is a stream overrun or underrun, which often happens when Julia is compiling, or with a particularly large GC run. Only affects duplex streams.\nwriter = PortAudio.SampledSignalsWriter(): the scribe that will write output. Defaults to a PortAudio.SampledSignalsReader. Users can pass custom scribes; see PortAudio.Scribe.\n\nExamples:\n\nSet up an audio pass-through from microphone to speaker\n\njulia> using PortAudio, SampledSignals\n\njulia> stream = PortAudioStream(2, 2; warn_xruns = false);\n\njulia> try\n            # cancel with Ctrl-C\n            write(stream, stream, 2s)\n        finally\n            close(stream)\n        end\n\nUse do syntax to auto-close the stream\n\njulia> using PortAudio, SampledSignals\n\njulia> PortAudioStream(2, 2; warn_xruns = false) do stream\n            write(stream, stream, 2s)\n        end\n\nOpen devices by name\n\nusing PortAudio, SampledSignals\nPortAudioStream(\"Built-in Microph\", \"Built-in Output\"; warn_xruns = false) do stream\n    write(stream, stream, 2s)\nend\n2 s\n\nRecord 10 seconds of audio and save to an ogg file\n\njulia> using PortAudio, SampledSignals, LibSndFile\n\njulia> PortAudioStream(2, 0; warn_xruns = false) do stream\n            buf = read(stream, 10s)\n            save(joinpath(tempname(), \".ogg\"), buf)\n        end\n2 s\n\n\n\n\n\n","category":"type"},{"location":"#PortAudio.devices-Tuple{}","page":"Public interface","title":"PortAudio.devices","text":"devices()\n\nList the devices available on your system. Devices will be shown with their internal name, and maximum input and output channels.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [PortAudio]\nPublic = false","category":"page"},{"location":"internals/#PortAudio.Buffer","page":"Internals","title":"PortAudio.Buffer","text":"struct PortAudio.Buffer{Sample}\n\nA PortAudio.Buffer contains everything you might need to read or write data from or to PortAudio. The data field contains the raw data in the buffer. Use PortAudio.write_buffer to write data to PortAudio, and PortAudio.read_buffer! to read data from PortAudio.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PortAudio.SampledSignalsReader","page":"Internals","title":"PortAudio.SampledSignalsReader","text":"struct PortAudio.SampledSignalsReader\n\nA PortAudio.Scribe that will use the SampledSignals package to manage reading data from PortAudio.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PortAudio.SampledSignalsWriter","page":"Internals","title":"PortAudio.SampledSignalsWriter","text":"struct PortAudio.SampledSignalsReader\n\nA PortAudio.Scribe that will use the SampledSignals package to manage writing data to PortAudio.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PortAudio.Scribe","page":"Internals","title":"PortAudio.Scribe","text":"abstract type PortAudio.Scribe end\n\nA scribe must implement the following:\n\nA method for PortAudio.get_input_type\nA method for PortAudio.get_output_type\nA method to call itself on two arguments: a PortAudio.Buffer and an input of the input type. This method must return an output of the output type. This method should make use of PortAudio.read_buffer! and PortAudio.write_buffer.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PortAudio.get_input_type-Tuple{PortAudio.SampledSignalsScribe, Any}","page":"Internals","title":"PortAudio.get_input_type","text":"PortAudio.get_input_type(scribe::PortAudio.Scribe, Sample)\n\nGet the input type of a PortAudio.Scribe for samples of type Sample.\n\n\n\n\n\n","category":"method"},{"location":"internals/#PortAudio.get_output_type-Tuple{PortAudio.SampledSignalsScribe, Any}","page":"Internals","title":"PortAudio.get_output_type","text":"PortAudio.get_input_type(scribe::PortAudio.Scribe, Sample)\n\nGet the output type of a PortAudio.Scribe for samples of type Sample.\n\n\n\n\n\n","category":"method"},{"location":"internals/#PortAudio.read_buffer!","page":"Internals","title":"PortAudio.read_buffer!","text":"PortAudio.read_buffer!(buffer::Buffer, use_frames = buffer.frames_per_buffer)\n\nRead a number of frames (use_frames) from PortAudio to a PortAudio.Buffer.\n\n\n\n\n\n","category":"function"},{"location":"internals/#PortAudio.write_buffer","page":"Internals","title":"PortAudio.write_buffer","text":"PortAudio.write_buffer(buffer, use_frames = buffer.frames_per_buffer)\n\nWrite a number of frames (use_frames) from a PortAudio.Buffer to PortAudio.\n\n\n\n\n\n","category":"function"}]
}
